# LEGAL NOTICE
# This computer software was prepared by Battelle Memorial Institute,
# hereinafter the Contractor, under Contract No. DE-AC05-76RL0 1830
# with the Department of Energy (DOE). NEITHER THE GOVERNMENT NOR THE
# CONTRACTOR MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY
# LIABILITY FOR THE USE OF THIS SOFTWARE. This notice including this
# sentence must appear on any copies of this computer software.
# 
# EXPORT CONTROL
# User agrees that the Software will not be shipped, transferred or
# exported into any country or used in any manner prohibited by the
# United States Export Administration Act or any other applicable
# export laws, restrictions or regulations (collectively the "Export Laws").
# Export of the Software may require some form of license or other
# authority from the U.S. Government, and failure to obtain such
# export control license may result in criminal liability under
# U.S. laws. In addition, if the Software is identified as export controlled
# items under the Export Laws, User represents and warrants that User
# is not a citizen, or otherwise located within, an embargoed nation
# (including without limitation Iran, Syria, Sudan, Cuba, and North Korea)
#     and that User is not otherwise prohibited
# under the Export Laws from receiving the Software.
# 
# Copyright 2011 Battelle Memorial Institute.  All Rights Reserved.
# Distributed as open-source under the terms of the Educational Community 
# License version 2.0 (ECL 2.0). http://www.opensource.org/licenses/ecl2.php
# 
# For further details, see: http://www.globalchange.umd.edu/models/gcam/
#

# diag_grapher.R
#
# An automated graphing system to process GCAM output data (as generated by the
# ModelInterface) and generate both standard and user-defined graphs.
#
# This file provides the actual graphing routines
# Note that the diag_header.R file needs to be source'd before this
#
# Ben Bond-Lamberty, September 2013


# -----------------------------------------------------------------------------
# configure_maps: read in and configure GIS map data
configure_maps <- function() {
    printlog( "Reading map data, if available..." )
    fn <- paste( GIS_DIR, GIS_FILE, ".csv", sep="" )
    if( file.exists( fn ) ) {
        # Need to specify map data classes because otherwise all hell breaks loose
        # Of course, if the format ever changes, this will break like fine china
        GCAM_MAPDATA <<- read.csv( fn, colClasses=c( "numeric", "numeric", "integer", 
            "logical", "factor", "factor", "character", "integer", "integer", "character") )
    } else {
        printlog( "Re-configuring map polygon data from shapefile; please wait..." )
        # Following code based on https://github.com/hadley/ggplot2/wiki/plotting-polygon-shapefiles
        # Assumes that rgdal, plyr, and maptools libraries have been loaded!
        gcam <- readOGR( paste( GIS_DIR, ".", sep="" ), layer=GIS_FILE )
        gcam@data$id <- rownames( gcam@data )
        gcam.points <- fortify( gcam, region="id" )
        GCAM_MAPDATA <<- join( gcam.points, gcam@data, by="id" )
        GCAM_MAPDATA$Region <<- REGION_NAMES[ GCAM_MAPDATA$MiniCAM ]
        write.csv( GCAM_MAPDATA, fn, row.names=F )
    }
    printlog( "Map data read OK" )
} # configure_maps


# -----------------------------------------------------------------------------
# add_to_title: add items to a graph's title, separated by OUTPUT_FILENAME_SEP
add_to_title <- function( p, ... ) {
    if( is.null( p$labels$title ) )
        p <- p + ggtitle( paste( ..., collapse=OUTPUT_FILENAME_SEP ) )
    else
        p <- p + ggtitle( paste( p$labels$title, paste(..., collapse=OUTPUT_FILENAME_SEP), sep=OUTPUT_FILENAME_SEP ) )
    printlog("Now", p$labels$title)
    p
} # add_to_title


# -----------------------------------------------------------------------------
# save_single_graph: save graph with data used to make it
save_single_graph <- function(  p=last_plot(),
                                graphfn=p$labels$title,
                                outputfolder=OUTPUT_DIR,
                                savegraph=SAVE_EACH_GRAPH,
                                savedata=SAVE_EACH_DATA )
{
    # -------------------- build plot title w/ unique number
    gnum <- formatC( GRAPH_NUMBER, width=3, flag="0" )
    GRAPH_NUMBER <<- GRAPH_NUMBER + 1

    # Use graph title as filename, stripping spaces etc.
    graphfn <- paste0( gnum, OUTPUT_FILENAME_SEP, graphfn, ".", OUTPUT_FILETYPE )
    graphfn <- gsub( " ", "", graphfn )                 # no spaces allowed
    graphfn <- gsub( "[^.A-Za-z0-9_-]", "", graphfn )       # nor unsafe characters

    if( savegraph ) {
        if( !file.exists( outputfolder ) ) dir.create( outputfolder )
        printlog( "Saving", graphfn )
        if( "save_args" %in% names( p ) ) {
            do.call( ggsave, c(list(filename=paste( outputfolder, graphfn, sep="/" ), plot=p), p$save_args ) )
        } else {
            ggsave( paste( outputfolder, graphfn, sep="/" ) )
        }
        p[[ "filter_data" ]][[ "graphfn" ]] <- graphfn
    }
    if( savedata ) {
        if( !file.exists( outputfolder ) ) dir.create( outputfolder )
        datafn <- paste( graphfn, ".csv", sep="" )
        printlog( "Saving", datafn )
        write.csv( p$data, paste( outputfolder, datafn, sep="/" ), row.names=F )
        p[[ "filter_data" ]][[ "datafn" ]] <- datafn
    }

    GRAPH_METADATA[[ GRAPH_NUMBER - 1 ]] <<- p[[ "filter_data" ]]
} # save_single_graph


# -----------------------------------------------------------------------------
# do_single_graph: build, display and save a single graph
# This function is the heart of the diagnostics system, and will generate and save a graph.
# Normally called only by do_graph, below.
do_single_graph <- function(    p,      # a ggplot
                                ylab=NA,
                                outputfolder=OUTPUT_DIR,
                                savegraph=SAVE_EACH_GRAPH,
                                savedata=SAVE_EACH_DATA,
                                map=F ) {
                                
    theme_set( theme_bw() )

    # -------------------- special case: user requests a map
    if( map ) {
        configure_maps()
        temp <- p$data[ , "value" ]
        names( temp ) <- p$data[ , p$labels$fill ]
        GCAM_MAPDATA$filldata <- temp[ GCAM_MAPDATA$Region ]
        GCAM_MAPDATA[ TITLE_FIELD_NAME ] <- p$labels$fill
        GCAM_MAPDATA[ UNITS_FIELD_NAME ] <- p$data[ 1, UNITS_FIELD_NAME ]

        newp <- ggplot( GCAM_MAPDATA, aes( long, lat, group=group  ) ) +
                labs( x='Longitude', y='Latitude' ) + 
                geom_polygon( aes( fill=filldata ) ) + geom_path( color='white' ) + 
                ggtitle( p$labels$title ) +
                scale_fill_continuous( p$data[ 1, TITLE_FIELD_NAME ] ) + coord_equal()
        p <- add_to_title( newp, "map", p$data[ 1, TITLE_FIELD_NAME ] ) # overwrite
    }
    
    # -------------------- try to give the plot a sensible y-axis label
    items <- paste( unique( p$data[ TITLE_FIELD_NAME ] ), collapse=OUTPUT_FILENAME_SEP )
    p <- add_to_title( p, items )
    if( is.na( ylab ) ) {
        p <- p + ylab( paste0( items, " (", paste( unique( p$data[ UNITS_FIELD_NAME ] ), collapse=" " ), ")" ) )
    } else {
        p <- p + ylab( ylab )
    }
    
    # -------------------- collect meta data on the plot
    if( !( "filter_data" %in% names( p ) ) ) {
        p$filter_data <- list()
    }
    # Add the title metadata to the plot.
    # Note the Diff or year_subset were added manually to the title so we
    # want to remvoe that in the metadata so it can be independently filtered.
    if( "diff_plot" %in% names( p[[ "filter_data" ]] ) ) {
        items <- sub( 'Diff\\.', '', items )
    } else {
        p[[ "filter_data" ]][[ "diff_plot" ]] <- FALSE
    }
    if( "year_subset" %in% names( p[[ "filter_data" ]] ) ) {
        items <- sub( paste0( p[[ "filter_data" ]][[ "year_subset" ]], '\\.' ), '', items )
    }
    p[[ "filter_data" ]][[ TITLE_FIELD_NAME ]] <- items

    # -------------------- try to display the plot (catching errors)
    errmsg <- NA
    printlog( "Plotting", p$labels$title, "...", level=LOGLEVEL_DETAIL )
    tryCatch( {
            if( DISPLAY_EACH_GRAPH )    print( p )
        }, error=function( err ) {
            printlog( "Oops...error trying to generate this graph", level=LOGLEVEL_ERROR )
            p <- qplot( 0, 0, label=paste( "ERROR", as.character( err ), sep="\n" ), geom="text", main=fn )
            errmsg <<- as.character( err )
            printlog( as.character( err ), level=LOGLEVEL_ERROR )
        }
    )

    save_single_graph( p )
    if( WAIT_EACH_GRAPH ) readline( "Waiting...<return>" )
    invisible( p )
} # do_single_graph

                        
# -----------------------------------------------------------------------------
# do_graph: build, display and save possibly multiple graphs

# Parameters: d (data frame), foldername (will be created if necessary), graphid (text), settings
do_graph <- function(   p,              # a ggplot
                        ylab=NA,
                        page_variables=NULL,
                        outputfolder=OUTPUT_DIR,
                        savegraph=SAVE_EACH_GRAPH,
                        savedata=SAVE_EACH_DATA,
                        map=F,
                        scales="free" ) {

    # If no title already assigned, generate a default one  
    #if( is.null( p$labels$title ) & !is.null( p$labels$x ) & !is.null( p$labels$y ) ) {
        #p <- add_to_title( p, p$labels$x, p$labels$y )
    #}

    # If scales need to be fixed across page_variables force it here
    if( scales %in% c( "fixed", "fixed_x" ) ) {
        x_var_name <- as.character( p$layers[[ 1 ]]$mapping$x )
        p <- p + scale_x_continuous( limits=c( min( p$data[, x_var_name] ), max( p$data[, x_var_name ] ) ) )
    }
    if( scales %in% c( "fixed", "fixed_y" ) ) {
        y_var_name <- as.character( p$layers[[ 1 ]]$mapping$y )
        if(p$layers[[1]]$position$.super$objname == "stack") {
            # TODO: not be correct for facets?
            x_var_name <- as.character( p$layers[[ 1 ]]$mapping$x )
            agg_formula <- as.formula( paste( y_var_name,
                paste( c( x_var_name, page_variables ), collapse="+"), sep="~") )
            print(agg_formula)
            paged_y_values <- aggregate( agg_formula, p$data, FUN=sum )
            y_min <- min( 0, min( paged_y_values[, y_var_name ] ) )
            y_max <- max( paged_y_values[, y_var_name ] )
        }
        else {
            y_min <- min( p$data[, y_var_name] )
            y_max <- max( p$data[, y_var_name ] )
        }
        p <- p + scale_y_continuous( limits=c( y_min,  y_max ) )
    }
    
    # This internal function is the d_ply dispatch; it receives data subsets,
    # updates the data and title of the base plot, and calls do_single_graph above
    f <- function( dsub, ... ) {    
        psub <- add_to_title( p, dsub[ 1, page_variables ] )

        # -------------------- collect meta data on the plot
        if( !( "filter_data" %in% names( psub ) ) ) {
            psub$filter_data <- list()
        }
        # Work around bug/feature where if page_variables is just one value then
        # a vector instead of a data.frame is returned.
        if( length( page_variables ) == 1 ) {
            psub[[ "filter_data" ]][[ page_variables ]] <- dsub[ 1, page_variables ]
        } else if( length( page_variables ) > 1 ) {
            psub[[ "filter_data" ]] <- c( psub[[ "filter_data" ]], as.list( dsub[ 1, page_variables ] ) )
        }

        do_single_graph( psub %+% dsub, ... )
    }

    # Split the data frame by requested variables, plotting all combinations
    if( is.null( page_variables ) ) {
        do_single_graph( p, ylab, outputfolder, savegraph, savedata, map ) 
    } else {
        d_ply( p$data, page_variables, f, 
            ylab, outputfolder, savegraph, savedata, map )  # .parallel=F but could try T
    }
} # do_graph

# -----------------------------------------------------------------------------
# generate_html_index: generate an HTML file which can be used to browse the
# created figures
# This method will modify a template HTML file to include the figure names as
# well as generate Javascript variables that include meta data useful for
# filtering the list of figures.
# Note that HTML_INDEX* file names are configured in the diag_header.R and
# the meta data is assumed to have been collected in GRAPH_METADATA.
generate_html_index <- function() {
    html_index_fn <- paste( OUTPUT_DIR, HTML_INDEX_FILE, sep="/" )
    html_js_fn <- paste( OUTPUT_DIR, HTML_JS_FILE, sep="/" )

    # Generate Javascript syntax for variables including meta data for
    # each figure and potential filter categories -> values
    filter_list <- list()
    figures_data_var <- c()
    for( i in 1:length(GRAPH_METADATA) ) {
        # skip figures that were not saved
        if( "graphfn" %in% names( GRAPH_METADATA[[ i ]] ) ) {
            curr_data_var <- c()
            for( key in names( GRAPH_METADATA[[ i ]] ) ) {
                # Names can't have a '.' in Javascript so just use '_' instead
                key.write <- sub( '\\.', '_', key )
                if( !( key %in% c( "graphfn", "datafn" ) ) ) {
                    filter_list[[ key ]] <- unique( c( filter_list[[ key ]],
                        as.character( GRAPH_METADATA[[ i ]][[ key ]] ) ) )
                }
                curr_data_var <- c( curr_data_var, paste( key.write, ': "',
                    GRAPH_METADATA[[ i ]][[ key ]], '"', sep="" ) )
            }
            figures_data_var <- c( figures_data_var, paste0( "{ ", paste( curr_data_var, collapse=", " ), " }" ) )
        }
    }
    filter_data_var <- c()
    for( key in names( filter_list ) ) {
        # Names can't have a '.' in Javascript so just use '_' instead
        key.write <- sub( '\\.', '_', key )
        filter_data_var <- c( filter_data_var, paste0( key.write, ': ["', paste( filter_list[[ key ]], collapse='", "' ), '"]' ) )
    }


    printlog( "Generating HTML index:", html_index_fn, "from:", HTML_INDEX_TEMPLATE )
    # the HTML doesn't acutally change so we can jsut copy.
    file.copy( HTML_INDEX_TEMPLATE, html_index_fn, overwrite=TRUE )

    printlog( "Generating HTML Javascript:", html_js_fn, "from:", HTML_JS_TEMPLATE )
    # Read in each line of the template
    contents <- scan( HTML_JS_TEMPLATE, what=character(), sep="\n", blank.lines.skip=FALSE )
    for(i in 1:length(contents)) {
        if( grepl( 'REPLACE_FIGURE_DATA', contents[ i ] ) ) {
            # Write the figure data as a variable instead of the content
            cat( "var figures_data = [", file=html_js_fn, sep="\n", append=TRUE)
            cat( figures_data_var, file=html_js_fn, sep=",\n", append=TRUE )
            cat( "];", file=html_js_fn, sep="\n", append=TRUE )
        }
        else if( grepl( 'REPLACE_FILTER_DATA', contents[ i ] ) ) {
            # Write the filter data as a variable instead of the content
            cat( "var filter_data = {", file=html_js_fn, sep="\n", append=TRUE )
            cat( filter_data_var, file=html_js_fn, sep=",\n", append=TRUE )
            cat( "};", file=html_js_fn, sep="\n", append=TRUE )
        }
        else {
            # Just copy the content from the template, if this is the first
            # line the we set append to FALSE meaning any previously existing
            # Javascript files will be overwritten.
            cat( contents[ i ], file=html_js_fn, sep="\n", append=(i!=1) )
        }
    }

} # generate_html_index
